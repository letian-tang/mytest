设计思想很简单。只要设置一个存放任务的阻塞队列，
让一个工作线程每次从该队列中取出一个任务并执行，
完毕再取下一个任务。由于单线程多任务，因此每个任务的粒度要充分小，
否则一个大任务会阻塞其他任务的执行。解决的办法是将一个大任务切分
成很多小任务，每个小任务能快速执行。（其实和CPU时间分片的原理一样）
由于在运行过程中会创建大量瞬时（instant)的任务对象，
可以预见在内存空间不充裕的情况下GC会比较频繁。 
(当然这和并发量也有关系，但即使只实现一个普通的计算需求，
比如计算一个级数的前100万项，也会产生至少100万个计算任务对象) 


代码中给出了三个例子，一个是利用级数求PI的近似值，
一个是读一个文本文件并统计每行文本的长度和单词数，
最后一个例子是将前两个例子合并起来，观察单线程异步的并发效果.  